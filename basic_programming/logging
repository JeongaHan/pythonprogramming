from apscheduler.schedulers.background import BackgroundScheduler
from elasticsearch import Elasticsearch
import os
import pandas as pd
import time
from itertools import zip_longest
import copy
from datetime import datetime, timedelta
from svlog import logged

ES_HOST = os.environ.get("ES_HOST", "dev-es.mllab.cc")
ES_PORT = os.environ.get("ES_PORT", "80")


# timestamp
# uniqueId
# ticketId
# userData
# qa

def run_scheduler():
    print("scheduler")
    res = load_from_es()
    ttt(res)
    return res


def load_from_es():
    es = Elasticsearch("{}:{}".format(ES_HOST, ES_PORT))
    index = "service-*"
    body = {
        "_source": ["@timestamp", "message"],
        "query": {
            "range": {
                "@timestamp": {
                    "gte": "2021-05-14||-1d",
                    "lte": "now"
                }
            }
        }
    }
    res = es.search(index=index, body=body)
    return res


def ttt(res):
    hits = res['hits']['hits']
    qa_list = list()
    timestamps = list()
    uniqueIds = list()
    userDatum = list()
    ticketIds = list()
    for hit in hits:
        source = hit['_source']
        timestamps.append(source['@timestamp'])
        api = source['message']['channel']['api']
        uniqueIds.append(api['request']['uniqueId'])
        userDatum.append(api['request']['userData'])
        ticketIds.append(api['response']['ticketId'])
        question, answer = parse_message(source['message'])
        qa = list()
        for q, a in zip_longest(question, answer):
            qa.append(q)
            if a is not None: qa.append(a)
        qa_list.append(qa)
    make_dataframe(timestamps, uniqueIds, userDatum, ticketIds, qa_list)
    return


def parse_message(messages):
    q, a = [], []
    q.append(messages['greeting']['message'])
    steplist = messages['serviceLogStepList']
    for step in steplist:
        a.append(step['nlp']['request']['message'])
        q.append(step['nlp']['response']['message'])
    return q, a


def make_dataframe(timestamp, uniqueId, userDatum, ticketId, qa_list):
    data = {}
    qamax = max([len(qa) for qa in qa_list])
    
    columns = [timestamp, uniqueId, userDatum, ticketId]
    
    df = pd.DataFrame(columns=)
    for i in range(len(timestamp)):
        data['timestamp'] = timestamp[i]
        data['uniqueId'] = uniqueId[i]
        data['userData'] = userDatum[i]
        data['ticketId'] = qa_list[i]
        for j in range(len(qa_list[i])):
            if j % 2 == 0:
                data['{}_{}'.format('q', j//2+1)] = qa_list[i][j]
            else:
                data['{}_{}'.format('a', j//2 + 1)] = qa_list[i][j]
        df.append(pd.DataFrame(data))
    print(df)

if __name__ == "__main__":
    scheduler = BackgroundScheduler()
    # scheduler.add_job(run_scheduler, 'interval', seconds=15)
    run_scheduler()
    scheduler.start()
    print("sched after")
    #
    # while True:
    #     time.sleep(1)
